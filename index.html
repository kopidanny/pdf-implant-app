<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <!-- Mobile-friendly viewport -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>PDF Implant App</title>
  <style>
    /* Basic Reset */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: Arial, sans-serif;
      background: #f8f8f8;
      color: #333;
      line-height: 1.4;
    }
    /* Header / Controls */
    header {
      background: #007ACC;
      color: #fff;
      padding: 10px;
      text-align: center;
    }
    header h1 {
      font-size: 1.4em;
      margin-bottom: 5px;
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      padding: 10px;
      background: #e0e0e0;
    }
    #controls button,
    #controls input,
    #controls label,
    #controls select {
      font-size: 1em;
      padding: 8px;
      border: none;
      border-radius: 4px;
    }
    #controls button {
      background: #007ACC;
      color: #fff;
      cursor: pointer;
    }
    #controls button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    #controls input[type="number"],
    #controls select {
      width: 70px;
      text-align: center;
    }
    /* Implant Menu */
    #implant-menu {
      position: fixed;
      top: 10px;
      right: 10px;
      background: #fff;
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 4px;
      z-index: 200;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      font-size: 0.9em;
      display: none; /* Hidden by default */
    }
    #implant-menu select,
    #implant-menu button {
      width: 100%;
      margin-top: 5px;
      padding: 8px;
      font-size: 0.9em;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    /* PDF Container */
    #pdf-container {
      position: relative;
      background: #fff;
      margin: 10px auto;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      max-width: 100%;
    }
    /* Canvas Styles with Explicit z-index */
    #pdf-canvas {
      position: relative;
      z-index: 1;
    }
    #implant-canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 2;
    }
    #overlay-canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 3;
    }
    /* Responsive adjustments */
    @media (max-width: 480px) {
      header h1 {
        font-size: 1.2em;
      }
      #controls button,
      #controls input,
      #controls label,
      #controls select {
        font-size: 0.9em;
        padding: 6px;
      }
      #implant-menu {
        font-size: 0.8em;
      }
    }
  </style>
</head>
<body>

  <header>
    <h1>PDF Implant App</h1>
    <p>Choose a mode below. In Ruler mode, tap to measure; in Implant mode, place and adjust implants.</p>
  </header>

  <div id="controls">
    <!-- PDF Navigation & File Input -->
    <input type="file" id="file-input" accept="application/pdf">
    <button id="prev-page" disabled>Prev Page</button>
    <button id="next-page" disabled>Next Page</button>

    <!-- Mode Dropdown -->
    <label for="mode-select">Mode:</label>
    <select id="mode-select">
      <option value="ruler">Ruler</option>
      <option value="implant">Implant</option>
    </select>

    <!-- Toggle Implant Menu Button (only shown in Implant mode) -->
    <button id="toggle-implant-menu" style="display:none;">Open Implant Menu</button>

    <!-- Clear Implants -->
    <button id="clear-implants">Clear Implant(s)</button>

    <!-- Zoom Controls -->
    <button id="zoom-in">Zoom In</button>
    <button id="zoom-out">Zoom Out</button>

    <!-- Calibration & Implant Height -->
    <label for="calibration-factor">Calib (pts/cm):</label>
    <input type="number" id="calibration-factor" value="28.346" step="0.1">
    <button id="set-calibration">Set</button>
    <label for="implant-height">Implant Height (cm):</label>
    <input type="number" id="implant-height" value="2" step="0.1">

    <!-- Measurement Result -->
    <span id="measurement-result"></span>
  </div>

  <!-- Implant Menu (Initially hidden) -->
  <div id="implant-menu">
    <p>Pinch & Twist near an implant to rotate it.</p>
    <label for="implant-select">Select Implant:</label>
    <select id="implant-select"></select>
    <button id="add-implant">Add Implant at Center</button>
  </div>

  <!-- PDF & Canvas Container -->
  <div id="pdf-container">
    <canvas id="pdf-canvas"></canvas>
    <canvas id="implant-canvas"></canvas>
    <canvas id="overlay-canvas"></canvas>
  </div>

  <!-- Include pdf.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.7.107/pdf.min.js"></script>
  <script>
    /***********************
     * PDF.js Setup
     ***********************/
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.7.107/pdf.worker.min.js';

    /***********************
     * Implant List & Preloading Images
     ***********************/
    const implantList = [
      { src: 'res/3.3x10mm.svg',    name: '3.3 x 10 mm' },
      { src: 'res/3.3x11.5mm.svg',  name: '3.3 x 11.5 mm' },
      { src: 'res/3.3x13mm.svg',    name: '3.3 x 13 mm' },
      { src: 'res/3.3x16mm.svg',    name: '3.3 x 16 mm' },
      { src: 'res/3.75x10mm.svg',   name: '3.75 x 10 mm' },
      { src: 'res/3.75x11.5mm.svg', name: '3.75 x 11.5 mm' },
      { src: 'res/3.75x13mm.svg',   name: '3.75 x 13 mm' },
      { src: 'res/3.75x16mm.svg',   name: '3.75 x 16 mm' },
      { src: 'res/4.2x8mm.svg',     name: '4.2 x 8 mm' },
      { src: 'res/4.2x10mm.svg',    name: '4.2 x 10 mm' },
      { src: 'res/4.2x11.5mm.svg',  name: '4.2 x 11.5 mm' },
      { src: 'res/4.2x13mm.svg',    name: '4.2 x 13 mm' },
      { src: 'res/4.2x16mm.svg',    name: '4.2 x 16 mm' },
      { src: 'res/5x8mm.svg',       name: '5 x 8 mm' },
      { src: 'res/5x10mm.svg',      name: '5 x 10 mm' },
      { src: 'res/5x11.5mm.svg',    name: '5 x 11.5 mm' },
      { src: 'res/5x13mm.svg',      name: '5 x 13 mm' },
      { src: 'res/5x16mm.svg',      name: '5 x 16 mm' }
    ];

    const implantImages = {};

    function parseImplantDimensions(src) {
      const regex = /(\d+(?:\.\d+)?)x(\d+(?:\.\d+)?)mm/i;
      const matches = src.match(regex);
      if (matches && matches.length >= 3) {
        return {
          widthMm: parseFloat(matches[1]),
          heightMm: parseFloat(matches[2])
        };
      }
      return null;
    }

    implantList.forEach(item => {
      const img = new Image();
      // Uncomment if necessary:
      // img.crossOrigin = "anonymous";
      img.src = item.src;
      img.onload = function() {
        const dims = parseImplantDimensions(item.src);
        implantImages[item.src] = { img: img, dims: dims };
        console.log("Loaded implant:", item.src, dims);
      };
      img.onerror = function(e) {
        console.error("Error loading implant image:", item.src, e);
      };
    });

    // Populate the implant dropdown in the implant menu.
    const implantSelect = document.getElementById('implant-select');
    implantList.forEach(item => {
      const option = document.createElement('option');
      option.value = item.src;
      option.textContent = item.name;
      implantSelect.appendChild(option);
    });
    let currentImplantSrc = implantSelect.value;
    implantSelect.addEventListener('change', function() {
      currentImplantSrc = this.value;
    });

    /***********************
     * Global DOM References & Variables
     ***********************/
    const fileInput = document.getElementById('file-input');
    const prevPageBtn = document.getElementById('prev-page');
    const nextPageBtn = document.getElementById('next-page');
    const modeSelectElem = document.getElementById('mode-select');
    const toggleImplantMenuBtn = document.getElementById('toggle-implant-menu');
    const clearImplantsBtn = document.getElementById('clear-implants');
    const zoomInBtn = document.getElementById('zoom-in');
    const zoomOutBtn = document.getElementById('zoom-out');
    const calibrationInput = document.getElementById('calibration-factor');
    const setCalibrationBtn = document.getElementById('set-calibration');
    const implantHeightInput = document.getElementById('implant-height');
    const measurementResult = document.getElementById('measurement-result');
    const pdfContainer = document.getElementById('pdf-container');
    const implantMenu = document.getElementById('implant-menu');

    const pdfCanvas = document.getElementById('pdf-canvas');
    const implantCanvas = document.getElementById('implant-canvas');
    const overlayCanvas = document.getElementById('overlay-canvas');

    const pdfCtx = pdfCanvas.getContext('2d');
    const implantCtx = implantCanvas.getContext('2d');
    const overlayCtx = overlayCanvas.getContext('2d');

    let pdfDoc = null;
    let currentPageNum = 1;
    let totalPages = 0;
    let pdfPage = null;
    let scale = 1.0;
    let pageViewport = null;
    let currentScale = scale;

    let measurementMode = false;
    let measurementPoints = [];

    let implantMode = false;
    let implantObjects = [];  // Each implant: { pdfX, pdfY, rotation, src }
    let selectedImplant = null;
    let dragOffset = { x: 0, y: 0 };

    let rotationGestureActive = false;
    let initialTwistAngle = 0;
    let initialRotation = 0;

    let calibrationFactor = parseFloat(calibrationInput.value) || 28.346;

    let pinchActive = false;
    let initialPinchDistance = 0;
    let initialScale = scale;

    /***********************
     * Mode Selection (Dropdown)
     ***********************/
    modeSelectElem.addEventListener('change', function() {
      const mode = modeSelectElem.value;
      if (mode === 'ruler') {
        measurementMode = true;
        implantMode = false;
        attachRulerEvents();
        detachImplantEvents();
        overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
        measurementPoints = [];
        implantMenu.style.display = 'none';
        toggleImplantMenuBtn.style.display = 'none';
      } else if (mode === 'implant') {
        measurementMode = false;
        implantMode = true;
        attachImplantEvents();
        detachRulerEvents();
        toggleImplantMenuBtn.style.display = 'inline-block';
      }
    });
    // Set initial mode to Ruler.
    modeSelectElem.value = 'ruler';
    attachRulerEvents();

    function attachRulerEvents() {
      overlayCanvas.style.pointerEvents = 'auto';
      overlayCanvas.addEventListener('click', onOverlayClick);
      overlayCanvas.addEventListener('touchend', onOverlayTouch);
    }
    function detachRulerEvents() {
      overlayCanvas.style.pointerEvents = 'none';
      overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      overlayCanvas.removeEventListener('click', onOverlayClick);
      overlayCanvas.removeEventListener('touchend', onOverlayTouch);
    }
    function attachImplantEvents() {
      implantCanvas.style.pointerEvents = 'auto';
      implantCanvas.addEventListener('click', onImplantClick);
      implantCanvas.addEventListener('mousedown', onImplantMouseDown);
      implantCanvas.addEventListener('touchstart', onImplantTouchStart);
    }
    function detachImplantEvents() {
      implantCanvas.style.pointerEvents = 'none';
      implantCanvas.removeEventListener('click', onImplantClick);
      implantCanvas.removeEventListener('mousedown', onImplantMouseDown);
      implantCanvas.removeEventListener('touchstart', onImplantTouchStart);
    }

    // Toggle Implant Menu manually.
    toggleImplantMenuBtn.addEventListener('click', function() {
      if (implantMenu.style.display === 'none' || implantMenu.style.display === '') {
        implantMenu.style.display = 'block';
        toggleImplantMenuBtn.textContent = "Close Implant Menu";
      } else {
        implantMenu.style.display = 'none';
        toggleImplantMenuBtn.textContent = "Open Implant Menu";
      }
    });

    // "Add Implant" button adds a new implant at the center.
    document.getElementById('add-implant').addEventListener('click', function() {
      const centerX = implantCanvas.width / 2;
      const centerY = implantCanvas.height / 2;
      placeImplantAt(centerX, centerY);
      // Optionally, select the newly added implant.
      selectedImplant = implantObjects[implantObjects.length - 1];
    });

    /***********************
     * PDF File Loading & Rendering
     ***********************/
    fileInput.addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file || file.type !== 'application/pdf') {
        alert('Please upload a valid PDF file.');
        return;
      }
      const fileReader = new FileReader();
      fileReader.onload = function() {
        const typedarray = new Uint8Array(this.result);
        pdfjsLib.getDocument(typedarray).promise.then(function(pdf) {
          pdfDoc = pdf;
          totalPages = pdf.numPages;
          currentPageNum = 1;
          prevPageBtn.disabled = (currentPageNum === 1);
          nextPageBtn.disabled = (currentPageNum === totalPages);
          loadPage(currentPageNum);
        }).catch(function(error) {
          console.error('Error loading PDF:', error);
        });
      };
      fileReader.readAsArrayBuffer(file);
    });

    function loadPage(num) {
      pdfDoc.getPage(num).then(function(page) {
        pdfPage = page;
        renderPage();
      });
    }

    function renderPage() {
      const viewport = pdfPage.getViewport({ scale: scale });
      pageViewport = viewport;
      currentScale = scale;
      pdfCanvas.width = viewport.width;
      pdfCanvas.height = viewport.height;
      implantCanvas.width = viewport.width;
      implantCanvas.height = viewport.height;
      overlayCanvas.width = viewport.width;
      overlayCanvas.height = viewport.height;
      pdfCtx.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
      implantCtx.clearRect(0, 0, implantCanvas.width, implantCanvas.height);
      overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      const renderContext = {
        canvasContext: pdfCtx,
        viewport: viewport
      };
      pdfPage.render(renderContext).promise.then(function() {
        redrawImplants();
      });
    }

    /***********************
     * Page Navigation & Zoom Controls
     ***********************/
    prevPageBtn.addEventListener('click', function() {
      if (currentPageNum <= 1) return;
      currentPageNum--;
      loadPage(currentPageNum);
      updatePageButtons();
    });
    nextPageBtn.addEventListener('click', function() {
      if (currentPageNum >= totalPages) return;
      currentPageNum++;
      loadPage(currentPageNum);
      updatePageButtons();
    });
    function updatePageButtons() {
      prevPageBtn.disabled = (currentPageNum === 1);
      nextPageBtn.disabled = (currentPageNum === totalPages);
      measurementPoints = [];
      overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      measurementResult.textContent = "";
    }
    zoomInBtn.addEventListener('click', function() {
      scale *= 1.1;
      renderPage();
    });
    zoomOutBtn.addEventListener('click', function() {
      scale /= 1.1;
      renderPage();
    });
    setCalibrationBtn.addEventListener('click', function() {
      const value = parseFloat(calibrationInput.value);
      if (isNaN(value) || value <= 0) {
        alert('Please enter a valid calibration factor.');
        return;
      }
      calibrationFactor = value;
      alert('Calibration factor set to ' + calibrationFactor + ' points per cm.');
      renderPage();
    });

    /***********************
     * Ruler Mode
     ***********************/
    function onOverlayClick(e) {
      const rect = overlayCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      processMeasurementPoint(x, y);
    }
    function onOverlayTouch(e) {
      const touch = e.changedTouches[0];
      const rect = overlayCanvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      processMeasurementPoint(x, y);
      e.preventDefault();
    }
    function processMeasurementPoint(x, y) {
      // If there are already two points, the next tap clears the measurement.
      if (measurementPoints.length >= 2) {
        measurementPoints = [];
        overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
        return;
      }
      measurementPoints.push({ x, y });
      if (measurementPoints.length === 1) {
        overlayCtx.fillStyle = "red";
        overlayCtx.beginPath();
        overlayCtx.arc(x, y, 5, 0, 2 * Math.PI);
        overlayCtx.fill();
      }
      if (measurementPoints.length === 2) {
        drawMeasurementLine(measurementPoints[0], measurementPoints[1]);
      }
    }
    function drawMeasurementLine(p1, p2) {
      overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
      overlayCtx.strokeStyle = "red";
      overlayCtx.lineWidth = 2;
      overlayCtx.beginPath();
      overlayCtx.moveTo(p1.x, p1.y);
      overlayCtx.lineTo(p2.x, p2.y);
      overlayCtx.stroke();
      // Draw endpoints
      overlayCtx.fillStyle = "blue";
      overlayCtx.beginPath();
      overlayCtx.arc(p1.x, p1.y, 5, 0, 2 * Math.PI);
      overlayCtx.fill();
      overlayCtx.beginPath();
      overlayCtx.arc(p2.x, p2.y, 5, 0, 2 * Math.PI);
      overlayCtx.fill();
      // Calculate and display distance near midpoint
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const distanceInPixels = Math.sqrt(dx * dx + dy * dy);
      const distanceInPDFPoints = distanceInPixels / scale;
      const distanceInCm = distanceInPDFPoints / calibrationFactor;
      const midX = (p1.x + p2.x) / 2;
      const midY = (p1.y + p2.y) / 2;
      overlayCtx.font = "14px Arial";
      overlayCtx.fillStyle = "black";
      overlayCtx.fillText(distanceInCm.toFixed(2) + " cm", midX + 5, midY - 5);
    }

    /***********************
     * Implant Mode
     ***********************/
    // Revised hit test: return the implant whose center is closest if within threshold.
    function findImplantAt(canvasX, canvasY) {
      let bestHit = null;
      let bestDistance = Infinity;
      for (let i = 0; i < implantObjects.length; i++) {
        const obj = implantObjects[i];
        const centerX = obj.pdfX * scale;
        const centerY = obj.pdfY * scale;
        const dx = canvasX - centerX;
        const dy = canvasY - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const { pixelWidth, pixelHeight } = getImplantPixelDimensions(obj);
        const threshold = Math.sqrt((pixelWidth / 2) ** 2 + (pixelHeight / 2) ** 2);
        if (distance < threshold && distance < bestDistance) {
          bestDistance = distance;
          bestHit = { index: i, implant: obj };
        }
      }
      return bestHit;
    }

    function placeImplantAt(canvasX, canvasY) {
      const pdfX = canvasX / scale;
      const pdfY = canvasY / scale;
      implantObjects.push({ pdfX, pdfY, rotation: 0, src: currentImplantSrc });
      redrawImplants();
    }

    function onImplantClick(e) {
      const rect = implantCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      // If tapping outside any implant, deselect any currently selected implant.
      const hit = findImplantAt(x, y);
      if (hit) {
        selectedImplant = hit.implant;
      } else {
        selectedImplant = null;
      }
    }

    function onImplantMouseDown(e) {
      const rect = implantCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const hit = findImplantAt(x, y);
      if (hit) {
        selectedImplant = hit.implant;
        const centerX = selectedImplant.pdfX * scale;
        const centerY = selectedImplant.pdfY * scale;
        dragOffset.x = x - centerX;
        dragOffset.y = y - centerY;
        window.addEventListener('mousemove', onImplantMouseMove);
        window.addEventListener('mouseup', onImplantMouseUp);
      }
    }

    function onImplantMouseMove(e) {
      if (!selectedImplant) return;
      const rect = implantCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const targetCenterX = (x - dragOffset.x) / scale;
      const targetCenterY = (y - dragOffset.y) / scale;
      selectedImplant.pdfX = targetCenterX;
      selectedImplant.pdfY = targetCenterY;
      redrawImplants();
    }

    function onImplantMouseUp(e) {
      // When mouse is released, deselect the implant so it is set in place.
      selectedImplant = null;
      window.removeEventListener('mousemove', onImplantMouseMove);
      window.removeEventListener('mouseup', onImplantMouseUp);
    }

    function onImplantTouchStart(e) {
      const rect = implantCanvas.getBoundingClientRect();
      if (e.touches.length === 2) {
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const dx = touch2.clientX - touch1.clientX;
        const dy = touch2.clientY - touch1.clientY;
        initialTwistAngle = Math.atan2(dy, dx);
        // Use midpoint for hit testing
        const midX = ((touch1.clientX + touch2.clientX) / 2) - rect.left;
        const midY = ((touch1.clientY + touch2.clientY) / 2) - rect.top;
        const hit = findImplantAt(midX, midY);
        if (hit) {
          selectedImplant = hit.implant;
        }
        initialRotation = selectedImplant ? (selectedImplant.rotation || 0) : 0;
        rotationGestureActive = true;
        e.preventDefault();
      } else if (e.touches.length === 1) {
        const touch = e.touches[0];
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;
        const hit = findImplantAt(x, y);
        if (hit) {
          selectedImplant = hit.implant;
          const centerX = selectedImplant.pdfX * scale;
          const centerY = selectedImplant.pdfY * scale;
          dragOffset.x = x - centerX;
          dragOffset.y = y - centerY;
          implantCanvas.addEventListener('touchmove', onImplantTouchMove);
          implantCanvas.addEventListener('touchend', onImplantTouchEnd);
        } else {
          selectedImplant = null;
        }
        e.preventDefault();
      }
    }

    function onImplantTouchMove(e) {
      if (rotationGestureActive && e.touches.length === 2 && selectedImplant) {
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const dx = touch2.clientX - touch1.clientX;
        const dy = touch2.clientY - touch1.clientY;
        const currentTwistAngle = Math.atan2(dy, dx);
        const deltaAngle = currentTwistAngle - initialTwistAngle;
        const deltaDegrees = deltaAngle * (180 / Math.PI);
        selectedImplant.rotation = initialRotation + deltaDegrees;
        redrawImplants();
        e.preventDefault();
      } else if (!rotationGestureActive && e.touches.length === 1 && selectedImplant) {
        const touch = e.touches[0];
        const rect = implantCanvas.getBoundingClientRect();
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;
        const targetCenterX = (x - dragOffset.x) / scale;
        const targetCenterY = (y - dragOffset.y) / scale;
        selectedImplant.pdfX = targetCenterX;
        selectedImplant.pdfY = targetCenterY;
        redrawImplants();
        e.preventDefault();
      }
    }

    function onImplantTouchEnd(e) {
      if (e.touches.length < 2) {
        rotationGestureActive = false;
      }
      if (e.touches.length === 0) {
        selectedImplant = null;
        implantCanvas.removeEventListener('touchmove', onImplantTouchMove);
        implantCanvas.removeEventListener('touchend', onImplantTouchEnd);
      }
      e.preventDefault();
    }

    function redrawImplants() {
      implantCtx.clearRect(0, 0, implantCanvas.width, implantCanvas.height);
      implantObjects.forEach(function(implant) {
        const { pixelWidth, pixelHeight } = getImplantPixelDimensions(implant);
        const centerX = implant.pdfX * scale;
        const centerY = implant.pdfY * scale;
        implantCtx.save();
        implantCtx.translate(centerX, centerY);
        implantCtx.rotate((implant.rotation || 0) * Math.PI / 180);
        if (implantImages[implant.src] && implantImages[implant.src].img.complete) {
          implantCtx.drawImage(implantImages[implant.src].img,
            -pixelWidth / 2, -pixelHeight / 2, pixelWidth, pixelHeight);
        }
        implantCtx.restore();
      });
    }

    function getImplantPixelDimensions(implant) {
      let pixelWidth, pixelHeight;
      const data = implantImages[implant.src];
      if (data && data.dims) {
        const widthCm = data.dims.widthMm / 10;
        const heightCm = data.dims.heightMm / 10;
        pixelWidth = widthCm * calibrationFactor * scale;
        pixelHeight = heightCm * calibrationFactor * scale;
      } else if (data && data.img) {
        const desiredHeightCm = parseFloat(implantHeightInput.value) || 2;
        const aspectRatio = (data.img.naturalWidth || 1) / (data.img.naturalHeight || 1);
        pixelHeight = desiredHeightCm * calibrationFactor * scale;
        pixelWidth = pixelHeight * aspectRatio;
      } else {
        pixelWidth = 50;
        pixelHeight = 50;
      }
      return { pixelWidth, pixelHeight };
    }

    clearImplantsBtn.addEventListener('click', function() {
      implantObjects = [];
      redrawImplants();
    });

    /***********************
     * Pinch-to-Zoom for PDF
     ***********************/
    function getDistance(touch1, touch2) {
      const dx = touch2.clientX - touch1.clientX;
      const dy = touch2.clientY - touch1.clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }
    pdfContainer.addEventListener('touchstart', function(e) {
      if (e.touches.length === 2) {
        pinchActive = true;
        initialPinchDistance = getDistance(e.touches[0], e.touches[1]);
        initialScale = scale;
        e.preventDefault();
      }
    }, { passive: false });
    pdfContainer.addEventListener('touchmove', function(e) {
      if (pinchActive && e.touches.length === 2) {
        const currentDistance = getDistance(e.touches[0], e.touches[1]);
        scale = initialScale * (currentDistance / initialPinchDistance);
        renderPage();
        e.preventDefault();
      }
    }, { passive: false });
    pdfContainer.addEventListener('touchend', function(e) {
      if (e.touches.length < 2) {
        pinchActive = false;
      }
    });
  </script>
</body>
</html>
